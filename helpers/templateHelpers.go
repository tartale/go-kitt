package helpers

import (
	"fmt"
	"strings"
	"sync"
	"text/template"

	"github.com/MarcGrol/golangAnnotations/generator/rest/restAnnotation"
	"github.com/MarcGrol/golangAnnotations/model"
	"github.com/Masterminds/sprig"
	"github.com/huandu/xstrings"
	"github.com/leekchan/gtf"

	"github.com/tartale/go-kitt/annotations"
	"github.com/tartale/go-kitt/config"
	"github.com/tartale/go-kitt/helpers/modelx"
)

var templateFuncs template.FuncMap
var templateFuncsInit sync.Once

func TemplateFuncs() template.FuncMap {
	templateFuncsInit.Do(func() {
		templateFuncs = make(template.FuncMap)
		templateFuncs["HeaderComment"] = HeaderComment
		templateFuncs["ShouldGenerateLogging"] = ShouldGenerateLogging
		templateFuncs["ShouldGenerateHttp"] = ShouldGenerateHttp
		templateFuncs["MethodSignature"] = MethodSignature

		templateFuncs["toDeclarations"] = toDeclarations
		templateFuncs["toStringAssignments"] = toStringAssignments
		templateFuncs["names"] = names
		templateFuncs["filtercontexts"] = filtercontexts
		templateFuncs["filtererrors"] = filtererrors
		templateFuncs["firsterror"] = firsterror
		templateFuncs["prefix"] = prefix
		templateFuncs["suffix"] = suffix
		templateFuncs["upperfirst"] = upperfirst
		templateFuncs["lowerfirst"] = lowerfirst
		templateFuncs["autoname"] = autoname
		templateFuncs["autotag"] = autotag

		for k, v := range sprig.GenericFuncMap() {
			templateFuncs[k] = v
		}
		// hack until sprig@v3.x is available
		templateFuncs["get"] = func(d map[string]interface{}, key string) interface{} {
			if val, ok := d[key]; ok {
				return val
			}
			return ""
		}
		for k, v := range gtf.GtfTextFuncMap {
			templateFuncs[k] = v
		}
	})

	return templateFuncs
}

func AddTemplateFunc(name string, fn interface{}) {
	templateFuncs[name] = fn
}

func TemplateHelpers() template.FuncMap {
	return TemplateFuncs()
}

func DocLines(obj interface{}) []string {

	switch v := obj.(type) {
	case model.Struct:
		return v.DocLines
	case model.Operation:
		return v.DocLines
	case model.Interface:
		return v.DocLines
	case model.Typedef:
		return v.DocLines
	case model.Enum:
		return v.DocLines
	default:
		return []string{}
	}

	return []string{}
}

const headerComment = `
/**
 * DO NOT EDIT - changes will be over-written
 * Generated by github.com/tartale/go-kitt
**/
`

func HeaderComment() string {
	return headerComment
}

func ShouldGenerateLogging(objs ...interface{}) bool {
	result := config.Config.LogAllMethods
	for _, obj := range objs {
		_, ok := annotations.AnnotationRegistry().ResolveAnnotationByName(DocLines(obj), annotations.TypeLogging)
		if ok {
			result = true
			break
		}
	}
	return result
}

func ShouldGenerateHttp(objs ...interface{}) bool {
	result := false
	for _, obj := range objs {
		_, ok := annotations.AnnotationRegistry().ResolveAnnotationByName(DocLines(obj), restAnnotation.TypeRestService)
		if ok {
			result = true
			break
		}
	}
	return result
}

func MethodSignature(obj model.Operation) string {
	toStrings := TemplateFuncs()["toStrings"].(func(interface{}) []string)
	inputs := autoname("input", obj.InputArgs).([]model.Field)
	inputDeclarations := toStrings(toDeclarations(inputs))
	outputs := autoname("output", obj.OutputArgs).([]model.Field)
	outputDeclarations := toStrings(toDeclarations(outputs))

	return fmt.Sprintf("%s(%s) (%s)", obj.Name,
		strings.Join(inputDeclarations, ", "),
		strings.Join(outputDeclarations, ", "))
}

func toDeclarations(value interface{}) interface{} {

	switch v := value.(type) {
	case model.Field:
		return modelx.Declaration{Field: v}
	case []model.Field:
		var result modelx.Declarations
		for _, field := range v {
			result = append(result, modelx.Declaration{Field: field})
		}
		return result
	default:
		return value
	}
}

func toStringAssignments(value interface{}) interface{} {

	switch v := value.(type) {
	case model.Field:
		var dereferencer string
		if v.IsPointer {
			dereferencer = "*"
		}
		result := modelx.Assignment{Field: v, RHS: `fmt.Sprintf("%+v", ` + dereferencer + v.Name + ")"}
		result.Field.Name = result.Field.Name + "String"
		return result
	case []model.Field:
		var result modelx.Assignments
		for _, field := range v {
			result = append(result, toStringAssignments(field).(modelx.Assignment))
		}
		return result
	}

	return value
}

func names(value interface{}) interface{} {

	switch v := value.(type) {
	case modelx.Declaration:
		return v.Field.Name
	case modelx.Declarations:
		var result []string
		for _, decl := range v {
			result = append(result, decl.Field.Name)
		}
		return result
	case modelx.Assignment:
		return v.Field.Name
	case modelx.Assignments:
		var result []string
		for _, assignment := range v {
			result = append(result, assignment.Field.Name)
		}
		return result
	case model.Field:
		return v.Name
	case []model.Field:
		var result []string
		for _, field := range v {
			result = append(result, field.Name)
		}
		return result
	}

	return value
}

func filtercontexts(value interface{}) interface{} {

	switch v := value.(type) {
	case []model.Field:
		var result []model.Field
		for _, field := range v {
			if field.TypeName == "context.Context" {
				continue
			}
			result = append(result, field)
		}
		return result
	}

	return value
}

func filtererrors(value interface{}) interface{} {

	switch v := value.(type) {
	case []model.Field:
		var result []model.Field
		for _, field := range v {
			if field.TypeName == "error" {
				continue
			}
			result = append(result, field)
		}
		return result
	}

	return value
}

func firsterror(value interface{}) interface{} {

	switch v := value.(type) {
	case []model.Field:
		for _, field := range v {
			if field.TypeName == "error" {
				return field
			}
		}
	}
	return nil
}

func prefix(prefix string, value interface{}) interface{} {

	switch v := value.(type) {
	case string:
		return fmt.Sprintf("%s%s", prefix, v)
	case []string:
		var result []string
		for _, s := range v {
			result = append(result, fmt.Sprintf("%s%s", prefix, s))
		}
		return result
	default:
		return value
	}
}

func suffix(suffix string, value interface{}) interface{} {

	switch v := value.(type) {
	case string:
		return fmt.Sprintf("%s%s", v, suffix)
	case []string:
		var result []string
		for _, s := range v {
			result = append(result, fmt.Sprintf("%s%s", s, suffix))
		}
		return result
	default:
		return value
	}
}

func upperfirst(value interface{}) interface{} {

	switch v := value.(type) {
	case string:
		return xstrings.FirstRuneToUpper(v)
	case []string:
		var result []string
		for _, s := range v {
			result = append(result, upperfirst(s).(string))
		}
		return result
	default:
		return value
	}
}

func lowerfirst(value interface{}) interface{} {

	switch v := value.(type) {
	case string:
		return xstrings.FirstRuneToLower(v)
	case []string:
		var result []string
		for _, s := range v {
			result = append(result, lowerfirst(s).(string))
		}
		return result
	default:
		return value
	}
}

func tofield(value interface{}) interface{} {
	switch v := value.(type) {
	case model.Field:
		return v
	case []model.Field:
		return v
	case string:
		declarationParts := strings.Fields(v)
		var result model.Field
		if len(declarationParts) >= 1 {
			result.Name = declarationParts[0]
		}
		if len(declarationParts) >= 2 {
			typeName := declarationParts[1]
			if strings.Contains(typeName, "*") {
				result.IsPointer = true
				typeName = strings.Trim(typeName, "*")
			}
			if strings.Contains(typeName, "[]") {
				result.IsSlice = true
				typeName = strings.Trim(typeName, "[]")
			}
			result.TypeName = typeName
		}
		if len(declarationParts) >= 3 {
			result.Tag = declarationParts[2]
		}
		return result
	case []string:
		var result []model.Field
		for _, s := range v {
			result = append(result, tofield(s).(model.Field))
		}
		return result
	default:
		return value
	}
}

func autoname(prefix string, args ...interface{}) interface{} {

	index := 0
	for _, arg := range args {
		switch v := arg.(type) {
		case int:
			index = v
			continue
		case model.Field:
			if v.Name != "" {
				return v
			}
			if v.TypeName == "error" {
				v.Name = "err"
				return v
			}
			if index >= 0 {
				v.Name = fmt.Sprintf("%s", prefix)
				return v
			}
			v.Name = fmt.Sprintf("%s%d", prefix, index)

			return v
		case []model.Field:
			var result []model.Field
			for i, field := range v {
				result = append(result, autoname(prefix, i, field).(model.Field))
			}
			return result
		default:
			return args[len(args)-1]
		}
	}

	return args[len(args)-1]
}

func autotag(value interface{}) interface{} {

	switch v := value.(type) {
	case model.Field:
		if v.Tag != "" {
			return v
		}
		if v.TypeName == "error" {
			v.Tag = fmt.Sprintf("`json:\"%s,omitempty\"`", xstrings.FirstRuneToLower(v.Name))
			return v
		}
		v.Tag = fmt.Sprintf("`json:\"%s\"`", xstrings.FirstRuneToLower(v.Name))
		return v
	case []model.Field:
		var result []model.Field
		for _, field := range v {
			result = append(result, autotag(field).(model.Field))
		}
		return result
	case modelx.Declaration:
		var result modelx.Declaration
		result.Field = autotag(v.Field).(model.Field)
		return result
	case modelx.Declarations:
		var result modelx.Declarations
		for _, decl := range v {
			decl.Field = autotag(decl.Field).(model.Field)
			result = append(result, decl)
		}
		return result
	case string:
		var result string
		field := tofield(v).(model.Field)
		field = autotag(field).(model.Field)
		result = toDeclarations(field).(modelx.Declaration).String()
		return result
	case []string:
		var result []string
		for _, s := range v {
			result = append(result, autotag(s).(string))
		}
		return result
	default:
		return value
	}
}
