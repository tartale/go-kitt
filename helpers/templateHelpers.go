package helpers

import (
	"fmt"
	"strings"
	"sync"
	"text/template"

	"github.com/MarcGrol/golangAnnotations/generator/rest/restAnnotation"
	"github.com/MarcGrol/golangAnnotations/model"
	"github.com/Masterminds/sprig"
	"github.com/leekchan/gtf"

	"github.com/tartale/go-kitt/annotations"
	"github.com/tartale/go-kitt/config"
)

var templateFuncs template.FuncMap
var templateFuncsInit sync.Once

func TemplateFuncs() template.FuncMap {
	templateFuncsInit.Do(func() {
		templateFuncs = make(template.FuncMap)
		templateFuncs["HeaderComment"] = HeaderComment
		templateFuncs["ShouldGenerateLogging"] = ShouldGenerateLogging
		templateFuncs["ShouldGenerateHttp"] = ShouldGenerateHttp
		templateFuncs["MethodSignature"] = MethodSignature
		templateFuncs["FieldAutoName"] = FieldAutoName
		templateFuncs["FieldsAutoName"] = FieldsAutoName
		templateFuncs["FieldDeclaration"] = FieldDeclaration
		templateFuncs["FieldDeclarations"] = FieldDeclarations
		templateFuncs["FieldNames"] = FieldNames
		templateFuncs["FieldsNoContext"] = FieldsNoContext
		templateFuncs["FieldsFirstError"] = FieldsFirstError
		templateFuncs["prefixAll"] = prefixAll

		for k, v := range sprig.GenericFuncMap() {
			templateFuncs[k] = v
		}
		// hack until sprig@v3.x is available
		templateFuncs["get"] = func(d map[string]interface{}, key string) interface{} {
			if val, ok := d[key]; ok {
				return val
			}
			return ""
		}
		for k, v := range gtf.GtfTextFuncMap {
			templateFuncs[k] = v
		}
	})

	return templateFuncs
}

func AddTemplateFunc(name string, fn interface{}) {
	templateFuncs[name] = fn
}

func TemplateHelpers() template.FuncMap {
	return TemplateFuncs()
}

func DocLines(obj interface{}) []string {

	switch v := obj.(type) {
	case model.Struct:
		return v.DocLines
	case model.Operation:
		return v.DocLines
	case model.Interface:
		return v.DocLines
	case model.Typedef:
		return v.DocLines
	case model.Enum:
		return v.DocLines
	default:
		return []string{}
	}

	return []string{}
}

const headerComment = `
/**
 * DO NOT EDIT - changes will be over-written
 * Generated by github.com/tartale/go-kitt
**/
`

func HeaderComment() string {
	return headerComment
}

func ShouldGenerateLogging(objs ...interface{}) bool {
	result := config.Config.LogAllMethods
	for _, obj := range objs {
		_, ok := annotations.AnnotationRegistry().ResolveAnnotationByName(DocLines(obj), annotations.TypeLogging)
		if ok {
			result = true
			break
		}
	}
	return result
}

func ShouldGenerateHttp(objs ...interface{}) bool {
	result := false
	for _, obj := range objs {
		_, ok := annotations.AnnotationRegistry().ResolveAnnotationByName(DocLines(obj), restAnnotation.TypeRestService)
		if ok {
			result = true
			break
		}
	}
	return result
}

func MethodSignature(obj model.Operation) string {
	return fmt.Sprintf("%s(%s) (%s)", obj.Name,
		strings.Join(FieldDeclarations(FieldsAutoName(obj.InputArgs, "input")), ", "),
		strings.Join(FieldDeclarations(FieldsAutoName(obj.OutputArgs, "output")), ", "))
}

func FieldAutoName(field model.Field, prefix string, index int) model.Field {
	if field.Name != "" {
		return field
	}
	if field.TypeName == "error" {
		field.Name = "err"
	} else {
		field.Name = fmt.Sprintf("%s%d", prefix, index)
	}

	return field
}

func FieldsAutoName(fields []model.Field, prefix string) []model.Field {
	var result []model.Field

	for i, field := range fields {
		result = append(result, FieldAutoName(field, prefix, i))
	}

	return result
}

func FieldDeclaration(field model.Field, index int) string {
	var fieldModifier string
	if field.IsSlice {
		fieldModifier = fmt.Sprintf("%s%s", fieldModifier, "[]")
	}
	if field.IsPointer {
		fieldModifier = fmt.Sprintf("%s%s", fieldModifier, "*")
	}
	fieldType := fmt.Sprintf("%s%s", fieldModifier, field.TypeName)

	return fmt.Sprintf("%s %s", field.Name, fieldType)
}

func FieldDeclarations(fields []model.Field) []string {
	var result []string
	for i, field := range fields {
		result = append(result, FieldDeclaration(field, i))
	}

	return result
}

func FieldNames(fields []model.Field) []string {
	var result []string
	for _, field := range fields {
		result = append(result, field.Name)
	}

	return result
}

func FieldsNoContext(fields []model.Field) []model.Field {
	var result []model.Field
	for _, field := range fields {
		if field.TypeName == "context.Context" {
			continue
		}
		result = append(result, field)
	}
	return result
}

func FieldsFirstError(fields []model.Field) *model.Field {
	for _, field := range fields {
		if field.TypeName == "error" {
			return &field
		}
	}
	return nil
}

func prefixAll(prefix string, v []string) []string {
	var result []string

	for _, s := range v {
		result = append(result, fmt.Sprintf("%s%s", prefix, s))
	}

	return result
}
