package helpers

import (
	"fmt"
	"strings"
	"sync"
	"text/template"

	"github.com/MarcGrol/golangAnnotations/generator/rest/restAnnotation"
	"github.com/MarcGrol/golangAnnotations/model"
	"github.com/Masterminds/sprig"
	"github.com/huandu/xstrings"
	"github.com/leekchan/gtf"
	"github.com/pkg/errors"

	"github.com/tartale/go-kitt/annotations"
	"github.com/tartale/go-kitt/config"
)

var templateFuncs template.FuncMap
var templateFuncsInit sync.Once

func TemplateFuncs() template.FuncMap {
	templateFuncsInit.Do(func() {
		templateFuncs = make(template.FuncMap)
		templateFuncs["HeaderComment"] = HeaderComment
		templateFuncs["ShouldGenerateLogging"] = ShouldGenerateLogging
		templateFuncs["ShouldGenerateHttp"] = ShouldGenerateHttp
		templateFuncs["MethodSignature"] = MethodSignature
		templateFuncs["FieldDeclaration"] = FieldDeclaration
		templateFuncs["FieldDeclarations"] = FieldDeclarations
		templateFuncs["FieldNames"] = FieldNames
		templateFuncs["FieldsNoContext"] = FieldsNoContext
		templateFuncs["FieldsFirstError"] = FieldsFirstError

		templateFuncs["prefix"] = prefix
		templateFuncs["suffix"] = suffix
		templateFuncs["upperfirst"] = upperfirst
		templateFuncs["lowerfirst"] = lowerfirst
		templateFuncs["autoname"] = autoname
		templateFuncs["autotag"] = autotag

		for k, v := range sprig.GenericFuncMap() {
			templateFuncs[k] = v
		}
		// hack until sprig@v3.x is available
		templateFuncs["get"] = func(d map[string]interface{}, key string) interface{} {
			if val, ok := d[key]; ok {
				return val
			}
			return ""
		}
		for k, v := range gtf.GtfTextFuncMap {
			templateFuncs[k] = v
		}
	})

	return templateFuncs
}

func AddTemplateFunc(name string, fn interface{}) {
	templateFuncs[name] = fn
}

func TemplateHelpers() template.FuncMap {
	return TemplateFuncs()
}

func DocLines(obj interface{}) []string {

	switch v := obj.(type) {
	case model.Struct:
		return v.DocLines
	case model.Operation:
		return v.DocLines
	case model.Interface:
		return v.DocLines
	case model.Typedef:
		return v.DocLines
	case model.Enum:
		return v.DocLines
	default:
		return []string{}
	}

	return []string{}
}

const headerComment = `
/**
 * DO NOT EDIT - changes will be over-written
 * Generated by github.com/tartale/go-kitt
**/
`

func HeaderComment() string {
	return headerComment
}

func ShouldGenerateLogging(objs ...interface{}) bool {
	result := config.Config.LogAllMethods
	for _, obj := range objs {
		_, ok := annotations.AnnotationRegistry().ResolveAnnotationByName(DocLines(obj), annotations.TypeLogging)
		if ok {
			result = true
			break
		}
	}
	return result
}

func ShouldGenerateHttp(objs ...interface{}) bool {
	result := false
	for _, obj := range objs {
		_, ok := annotations.AnnotationRegistry().ResolveAnnotationByName(DocLines(obj), restAnnotation.TypeRestService)
		if ok {
			result = true
			break
		}
	}
	return result
}

func MethodSignature(obj model.Operation) string {
	inputs := autoname("input", 0, obj.InputArgs).([]model.Field)
	outputs := autoname("output", 0, obj.OutputArgs).([]model.Field)
	return fmt.Sprintf("%s(%s) (%s)", obj.Name,
		strings.Join(FieldDeclarations(inputs), ", "),
		strings.Join(FieldDeclarations(outputs), ", "))
}

func FieldDeclaration(field model.Field) string {
	var fieldModifier string
	if field.IsSlice {
		fieldModifier = fmt.Sprintf("%s%s", fieldModifier, "[]")
	}
	if field.IsPointer {
		fieldModifier = fmt.Sprintf("%s%s", fieldModifier, "*")
	}
	fieldType := fmt.Sprintf("%s%s", fieldModifier, field.TypeName)

	return fmt.Sprintf("%s %s %s", field.Name, fieldType, field.Tag)
}

func FieldDeclarations(fields []model.Field) []string {
	var result []string
	for _, field := range fields {
		result = append(result, FieldDeclaration(field))
	}

	return result
}

func FieldNames(fields []model.Field) []string {
	var result []string
	for _, field := range fields {
		result = append(result, field.Name)
	}

	return result
}

func FieldsNoContext(fields []model.Field) []model.Field {
	var result []model.Field
	for _, field := range fields {
		if field.TypeName == "context.Context" {
			continue
		}
		result = append(result, field)
	}
	return result
}

func FieldsFirstError(fields []model.Field) *model.Field {
	for _, field := range fields {
		if field.TypeName == "error" {
			return &field
		}
	}
	return nil
}

func prefix(prefix string, value interface{}) interface{} {

	switch v := value.(type) {
	case string:
		return fmt.Sprintf("%s%s", prefix, v)
	case []string:
		var result []string
		for _, s := range v {
			result = append(result, fmt.Sprintf("%s%s", prefix, s))
		}
		return result
	default:
		panic(fmt.Errorf("Unexpected type: %T", v))
	}
}

func suffix(suffix string, value interface{}) interface{} {

	switch v := value.(type) {
	case string:
		return fmt.Sprintf("%s%s", v, suffix)
	case []string:
		var result []string
		for _, s := range v {
			result = append(result, fmt.Sprintf("%s%s", s, suffix))
		}
		return result
	default:
		panic(fmt.Errorf("Unexpected type: %T", v))
	}
}

func upperfirst(value interface{}) interface{} {

	switch v := value.(type) {
	case string:
		return xstrings.FirstRuneToUpper(v)
	case []string:
		var result []string
		for _, s := range v {
			result = append(result, upperfirst(s).(string))
		}
		return result
	default:
		panic(fmt.Errorf("Unexpected type: %T", v))
	}
}

func lowerfirst(value interface{}) interface{} {

	switch v := value.(type) {
	case string:
		return xstrings.FirstRuneToLower(v)
	case []string:
		var result []string
		for _, s := range v {
			result = append(result, lowerfirst(s).(string))
		}
		return result
	default:
		panic(fmt.Errorf("Unexpected type: %T", v))
	}
}

func tofield(value interface{}) interface{} {
	switch v := value.(type) {
	case model.Field:
		return v
	case []model.Field:
		return v
	case string:
		declarationParts := strings.Fields(v)
		var result model.Field
		if len(declarationParts) >= 1 {
			result.Name = declarationParts[0]
		}
		if len(declarationParts) >= 2 {
			typeName := declarationParts[1]
			if strings.Contains(typeName, "*") {
				result.IsPointer = true
				typeName = strings.Trim(typeName, "*")
			}
			if strings.Contains(typeName, "[]") {
				result.IsSlice = true
				typeName = strings.Trim(typeName, "[]")
			}
			result.TypeName = typeName
		}
		if len(declarationParts) >= 3 {
			result.Tag = declarationParts[2]
		}
		return result
	case []string:
		var result []model.Field
		for _, s := range v {
			result = append(result, tofield(s).(model.Field))
		}
		return result
	default:
		panic(fmt.Errorf("Unexpected type: %T", v))
	}
}

func autoname(prefix string, args ...interface{}) interface{} {

	index := 0

	for _, arg := range args {
		switch v := arg.(type) {
		case int:
			index = v
			continue
		case model.Field:
			if v.Name != "" {
				return v
			}
			if v.TypeName == "error" {
				v.Name = "err"
				return v
			}
			if index >= 0 {
				v.Name = fmt.Sprintf("%s", prefix)
				return v
			}
			v.Name = fmt.Sprintf("%s%d", prefix, index)

			return v
		case []model.Field:
			var result []model.Field
			for i, field := range v {
				result = append(result, autoname(prefix, i, field).(model.Field))
			}
			return result
		default:
			panic(fmt.Errorf("Unexpected type: %T", v))
		}
	}

	panic(errors.New("usage: {{ model.Field or []model.Field }} | autoname \"prefix\" [index]"))
}

func autotag(value interface{}) interface{} {

	switch v := value.(type) {
	case model.Field:
		if v.Tag != "" {
			return v
		}
		if v.TypeName == "error" {
			v.Tag = fmt.Sprintf("`json:\"%s,omitempty\"`", xstrings.FirstRuneToLower(v.Name))
			return v
		}
		v.Tag = fmt.Sprintf("`json:\"%s\"`", xstrings.FirstRuneToLower(v.Name))
		return v
	case []model.Field:
		var result []model.Field
		for _, field := range v {
			result = append(result, autotag(field).(model.Field))
		}
		return result
	case string:
		field := tofield(v).(model.Field)
		field = autotag(field).(model.Field)
		return FieldDeclaration(field)
	case []string:
		var result []string
		for _, s := range v {
			result = append(result, autotag(s).(string))
		}
		return result
	default:
		panic(fmt.Errorf("Unexpected type: %T", v))
	}
}
